---
title: "Advanced R:\nTidyverse"
author: "January Weiner"
date: "`r Sys.Date()`"
output:
  ioslides_presentation:
    widescreen: true
    smaller: true
    css: "../files/style.css"
---

```{r echo=FALSE,results="hide",message=FALSE,warning=FALSE}
library(tidyverse)
```


# Tidyverse

## Why tidyverse

> * Cleaner code
> * Useful automatisation
> * Great data processing language
> * Coherent structure of packages

## Why *not* tidyverse

> * Changes the logic of the language
> * Makes your code depend on tidyverse
> * Fewer people will understand your code
> * Easy things are even easier, hard things are even harder
> * Useful mostly for data frames and lists (but that's not entirely true)


# My god, it's full of packages

## Tidyverse overview

![](../files/01_tidyverse_data_science.png){width=600px}

## Tidyverse packages

|Package|What does it do|What does it replace / introduce|
|-------|---------------|---------------------|
|rlang|Main tidyverse framework, a redefinition of R|A lot of base R constructs; introduces quosures|
|tibble|New model of data frames|data frames|
|dplyr|Main data frame manipulation tool|data frame operations|
|tidyr|Manipulating data formats, pivoting|e.g. reshape & co|
|magrittr|Introducing pipes to R|The `%>%` operator & co|
|purrr|Functional constructs|lapply, sapply & co|
|readr|read and write data frames|read.table & co|
|forcats|dealing with factors|introduces goodies for working with factors|
|stringr|dealing with strings|introduces goodies for working with strings|
|broom|standardizing output of common functions|`summary()`|
|ggplot2|Graphics based on "Grammar of graphics"|replaces base plotting utilities|

## How to use tidyverse

 * load with `library(tidyverse)`
 * some packages (e.g. `magrittr`) need to be loaded separately
 * never load `plyr` after `dplyr`

# Introducing tibbles

## So many ways to skin a cat

data.frame has so many problems. Luckily, there are also so many solutions.

 * data.table / DT
 * DataFrame
 * colorDF ;-)
 * tibble (tidyverse, formerly known as data\_frame)
 * special objects (ExpressionSet, limma/edgeR objects etc.)

## What is special about tibble

 * Hadley Wickham hates row names
 * tbl[,3] returns a tbl rather than a vector
 * nicer printing (but... colorDF is better ;-)
 * extra properties (`group_by` etc.)

## Fine, but...

If you want to view more than the default portion of the tibble, do

```{r,results="hide"}
print(starwars, n=Inf, width=Inf)
```

Row names: convert them to a column, use filter() instead of `[`

## Reading data with readr

 * read\_{tsv,csv,...}, write…
 * better, cleaner, faster
 * explicit
 * will never turn a string into a factor

## Reading data

---------------------------- ------------------------------- -------------------------- --------------------------
Data type                    Function                        Tidyverse                  Notes                     
---------------------------- ------------------------------- -------------------------- --------------------------
TSV / TAB separated values   `read.table()`                  `read_tsv()`,              Tab is `\t`.              
                                                             `read_delim()`             A very general and        
                                                                                        customizable function
                                                                                                                  
CSV / comma separated        `read.csv()`,                    `read_csv()`,             a wrapper around          
                                                              `read_delim()`            `read.table()`            
                                                                                                                  
XLS (old Excel)                                               `read_xls()`,             Avoid it!!!               
                                                              `read_excel()`            From the                  
                                                                                        `readxl`
                                                                                        package.
                                                                                                                  
XLSX (new Excel)                                              `read_xlsx()`,            From the `readxl` package.      
                                                              `read_excel()`            You need to                     
                                                                                        provide the
                                                                                        sheet number
                                                                                        you wish to
                                                                                        read. 
                                                                                        Note: returns a tibble,
                                                                                        not a data frame! 
---------------------------- ------------------------------- -------------------------- --------------------------



## Exercise Session 2/1

# Introducing Pipes

## Introducing Pipes

Remember? In R, almost everything is a function, but some functions are special: they
look like operators.

```{r echo=TRUE,results="markdown"}
vec <- 1:10
`[`(vec, 2)

`+`(1, 2)
```

## Introducing Pipes

It is possible to create your own functions which work like operators.

```{r echo=TRUE,results="markdown"}
`%cup%` <- function(x, y) union(x, y)
1:10 %cup% 2:15

`%cap%` <- function(x, y) intersect(x, y)
1:10 %cap% 2:15
```

The names for the operators here come from the $\LaTeX$ symbol names for
mathematical set operators $\cup$ ("cup") and $\cap$ ("cap").

<div class="columns-2">
</div>

## Introducing Pipes

How about an operator that calls just any function? 

```{r, eval=FALSE}
a %>% some_func(b)

## is the same as

`%>%`(a, some_func(b))

## is the same as
some_func(a, b)
```

## Introducing Pipes

Pipes work for *anything*, not just the tidyverse!

```{r}
df <- data.frame(1:1000)

df %>% head
```

## Pipes in full: magrittr package

![](../files/MagrittePipe.jpg){width=600px}

## Ceci n'est pas une pipe

Magrittr defines a number of aliases – and of course the pipe operator,
`%>%`.
However, there is more to this package.

 * aliases (extract, set\_names etc.)
 * `%$%` operator (pipe version of `attach`)
 * `%<>%` operator (instant assignment)



# dplyr

## dplyr: managing data

 * select, mutate, filter, rename, pull, arrange
 * distinct, sample\_{n,frac}, add\_count, add\_tally
 * summarise, \_at, \_if
 * group\_by

(Demo)

## select

Select columns from data:

    mtcars %>% select(mpg)
    mtcars %>% select(mpg, Cylinder=cyl)
    mtcars %>% select(starts_with("d"))

## mutate

Create new columns

    mtcars %>% mutate(lp100km=282.5/mpg)

## filter

Select rows from the data

    mtcars %>% filter(hp > 100)
    mtcars %>% filter(hp > 100 & cyl < 8)

## pull

Get a single column as a vector

    mtcars %>% pull(mpg)

## arrange

Sort the rows of the data 

    mtcars %>% arrange(mpg)

## Exercise Session 2/2

# tidyr

## Long vs wide data

 `gather()`, `spread()`

## Converting from wide to long:

```{r, results="hide"}
wide <- read.table(header=TRUE, text='
 subject sex control cond1 cond2
       1   M     7.9  12.3  10.7
       2   F     6.3  10.6  11.1
       3   F     9.5  13.1  13.8
       4   M    11.5  13.4  12.9
')
tidyr::gather(wide, key="condition", 
             value="measurement",  control:cond2)
```

`tidyr::gather` means we are accessing the `gather()` function from the
`tidyr` package without having to call `library(tidyr)` first.

## Converting from wide to long:

```{r}
wide <- read.table(header=TRUE, text='
 subject sex control cond1 cond2
       1   M     7.9  12.3  10.7
       2   F     6.3  10.6  11.1
       3   F     9.5  13.1  13.8
       4   M    11.5  13.4  12.9
')
tidyr::gather(wide, key="condition", 
             value="measurement",  control:cond2)
```


## Converting from long to wide

```{r}
long <- read.table(header=TRUE, text='
 subject  sampleID sex condition measurement
       1  ID000001 M   control         7.9
       1  ID000002 M     cond1        12.3
       1  ID000003 M     cond2        10.7
       2  ID000004 F   control         6.3
       2  ID000005 F     cond1        10.6
       2  ID000006 F     cond2        11.1
       3  ID000007 F   control         9.5
       3  ID000008 F     cond1        13.1
       3  ID000009 F     cond2        13.8
')
```

## Converting from long to wide

```{r}
## not what we wanted!!!
tidyr::spread(long, key="condition", value="measurement")

## Instead: 
long <- long[ , c("subject", "condition", "measurement") ]
tidyr::spread(long, key="condition", value="measurement")
```



## group\_by

Essentially, add information to the tibble that the data is grouped by a
variable. This does not change the actual data!

```{r}
identical(table2, table2 %>% group_by(country))
identical(as.data.frame(table2), 
          as.data.frame(table2 %>% group_by(country)))
```

You can then use several other functions.

## Use with caution!

While tidyverse is great for interactive work, you should use it with
caution in your packages:

```{r eval=FALSE}
foo <- function(df) {
  cols <- c("sex", "age")
  df %<>% select(cols)

  # ... do something

  return(df)
} 
```

What happens when df contains `cols`?

## Solution

Be wary of tidyverse shortcuts. Always assume the worst case scenario and
be explicit in your code:

```{r eval=FALSE}
# make sure you select columns from variable 
# and not by name
df %<>% select(!!cols)
```


## Exercise Session 2/3

# Mapping

## Mapping in R / in R + tidyverse

```{r}
tmp <- list(a=1, b=2, c=1:10)

lapply(tmp, length)
lapply(tmp, function(x) paste(x, collapse=", "))
```

## Mapping in R / in R + tidyverse

```{r}
map(tmp, ~ paste(., collapse=", "))

## type conversion is always specified
map_chr(tmp, ~ paste(., collapse=", "))
```


## Why both worlds?

 * The \*pply functions are still widely used, so you will see them in code
 * sometimes using tidyverse does not really give you a bonus

## lapply & sapply

`lapply` takes a list and returns a list, always.

`sapply` takes a list and tries to simplify it to a relevant object (data
frame, vector etc.). Which sometimes fails.

Compare:

```{r,eval=FALSE}
lapply(starwars$name, nchar)
sapply(starwars$name, nchar)
```


(Demo)

## `replicate`

This is a special form of `sapply` which simply calls a function `n` times
and returns the results in a list. Note that it uses an expression and not
a function as a second argument.

```r
## create 10 vectors with random numbers
replicate(10, rnorm(10), simplify=FALSE)
```

## General form

```r
xxxapply(data, ..., function)
```

Where `function` can be a closure (anonymous function), defined in place:

```r
## replace spaces by underscores
sapply(starwars$name, 
  function(x) 
      gsub(" ", "_", starwars$name))
```

## apply

`apply` is for data frames and matrices (two-dimensional objects).
The second argument determines whether it works row-wise (1) or column-wise
(2):


```r
## matrix of random numbers, 3 x 20
mtx <- matrix(rnorm(60), ncol=3)

apply(mtx, 1, sum)
apply(mtx, 2, sum)
```

## There is a simpler way

Don't forget following convenience functions:

 * `colSums`, `colMeans`
 * `rowSums`, `rowMeans`

## tapply

`tapply`  applies a function to vector split by levels of a factor. For
example, we might want to know what is the mean mpg for cars with different
number of cylinders:

    tapply(mtcars$mpg, mtcars$cyl, mean)

This is a really important function.

# Mapping in dplyr

## `group_by`

`group_by` introduces a grouping in a data frame that can be then used by
`summarise` to calculate something reasonable. This is a lot like `tapply`.

```r
mtcars %>% group_by(cyl) %>%
  summarise(m.hp=mean(hp))
```

## `group_by`

This has the advantage that you can define a whole range of calculations
based on any column in the data:

```r
mtcars %>% group_by(cyl) %>%
  summarise(m.hp=mean(hp), m.wt=mean(wt))
```

Or you can use a more complex function:

```r
## which planet has the largest mean BMI?
starwars %>% group_by(homeworld) %>%
  summarise(bmi = mean(mass/(height/100)^2))
```

## Weird, weird world (heavy stuff)

What if we don't want to choose a variable by hand?

```r
mtcars %>% group_by(cyl) %>% summarise_all(mean)
```

Or, if we want something more complex, we use the `~ ...` form:

```r
mtcars %>% group_by(cyl) %>% summarise_all(~ mean(.)/sd(.))
```

The dot (`.`) stands for the argument. 

# `purrr`

## `map` and co.

`map` works very much like `sapply(..., simplify=F)`, and its variants
explicitely try to cast the result in an appriopriate format.

 * `map_lgl` -- logical vector
 * `map_chr` -- character vector
 * `map_int` -- integer vector
 * `map_dbl` -- double (floating point) vector

## The weird syntax of `map`

To make the map functions more terse, map family adopted a particular way
of formulating custom functions. `.` (dot) is automatically used as
argument, and instead of writing `function(x) ...` you write `~ ...`:

 * sapply:

        ## return 1, 2, ... 10 random numbers
        sapply(1:10, function(x) rnorm(x))

 * map:

        map(1:10, ~ rnorm(.))

## Formula notation in dplyr

The same notation can be used also in dplyr with the `mutate_all` and
`rename_all` functions:

    ## Replace "none" by NA 
    starwars %>% mutate_all(~ gsub("none", NA, .))

    ## Modify all variable names
    starwars %>% rename_all(~ paste0("Var_", .))

## `map_dfr` and `map_dfc`

These two create a data frame. If your function returns each time a data
frame, map will join these – either by rows (`map_dfr`) or by
columns (`map_dfc`).

    ## create a list with 10 random vectors
    rv <- map(1:10, ~ rnorm(10))
    names(rv) <- LETTERS(1:10)

    ## calculate the mean and sd
    map_dfc(rv, ~ data.frame(mean=mean(.), sd=sd(.)))

## `map2` et co.

Sometimes you want to go over two or more vectors at the same time. 
Instead of `.` you have two automatic variable names, `.x` and `.y`.

    ## add number of vehicles to each name
    sw_names <- starwars$name
    sw_vehcls <- starwars$vehicles
    map2_chr(sw_names, sw_vehcls, 
      ~ paste0(.x, "_", length(.y)))


## `pmap` and co.

You can also use `pmap` to apply it to a list of vectors in which each
vector has the same length. But remember: data.frame is also a list! So you
can apply pmap to a data frame and process each row.

    starwars %>% 
      select(name, hair_color, eye_color) %>% 
      mutate_all(~ gsub("none", NA, .)) %>%
      drop_na() %>%
      pmap_chr(~ sprintf("%s has %s hair and %s eyes", ...))




